# 트리

## 개념
- 비선형 구조
- 1:n의 관계를 가지는 자료구조
- 계층형 구조
- 하나 이상의 노드로 이뤄진 유한 집합
    + 최상위 노드 = 루트
    + 나머지 노드들을 분리집합으로 분리 가능
    
<br>

- ```노드```: 트리의 가장 작은 원소
  + 루트 노드: 가장 최상위 노드
  + 형제 노드: 부모가 같은 자식 노드
  + 조상 노드: 루트 노드에 이르기까지의 경로에 있는 모든 노드들
  + 자손 노드: 서브 트리에 있는 모든 하위 노드들
  + 단말 노드: 자식 노드가 없는 노드
    

- 간선: 노드들을 연결한 선
- 차수
  + 노드의 차수: 노드에 연결된 ```자식노드```의 수
  + 트리의 차수: 트리의 노드 차수 중 가장 큰 값
    

- 높이
    + 노드의 높이: 루트에 이르는 간선 수
    + 트리의 높이: 가장 큰 노드 레벨 값
    + 레벨 = 높이
    

---
## 이진 트리
> 모든 노드들이 2개의 서브트리를 갖는 형태
> <br> 각 노드의 자식 노드를 최대 2개만 가질 수 있는 트리
> <br> ↔ 다진 트리
- 높이 h인 이진트리가 가질 수 있는 노드의 최소 개수 = ```h + 1```
- 최대 개수 = ```2^(h + 1) - 1```

## 포화 이진 트리

- 모든 레벨의 노드가 포화 상태인 이진 트리
- 넓은 의미에서 완전 이진 트리

## 완전 이진 트리

- 높이가 H이고 노드 수가 n일때, 1번 부터 n번까지 빈 자리가 없는 이진 트리

## 편향 이진 트리

- h에 대한 최소 개수의 노드를 가지면서 한 쪽 방향만 자식 노드를 가지는 트리

## 이진 트리 표현

- 레벨 n에 있는 노드에 대해 왼쪽부터 오른쪽으로 차례대로 번호 부여
- 노드 번호 성질
    - i의 부모 노드 = roundDown( i / 2 )
    - i의 왼쪽 자식 노드 = i * 2
    - i의 오른쪽 자식 노드 = I * 2 + 1

- 배열로 표현할 경우의 문제
    - 편향 이진 트리의 경우, 메모리 낭비가 심함
    - 새로운 노드 추가 or 노드 삭제의 경우, 배열 크기 변경이 어려움
    - SO, LinkedList를 이용해 트리 표현
- LinkedList로 트리 표현
    - 필요할 때마다 붙이면서 추가 가능

## 이진 트리 순회

1. 전위 순회
    - 부모노드 방문 후, 자식노드를 좌우 순서로 방문

```java
class PreOrder {

	preorder_traverse(Node T) {
		if (T != null) {
			visited(T);
			preorder_traverse(T.left);
			preorder_traverse(T.right);
		}
	}
}
```

2. 중위 순회
    - 왼쪽 자식노드, 부모 노드, 오른쪽 자식 노드 순으로 방문

```java
class inOrder {

	inorder_traverse(Node T) {
		if (T != null) {
			preorder_traverse(T.left);
			visited(T);
			preorder_traverse(T.right);
		}
	}
}
```

1. 후위 순회
    - 자식노드 좌우 방문 후, 부모 노드 순으로 방문

```java
class PostOrder {

	postorder_traverse(Node T) {
		if (T != null) {
			preorder_traverse(T.left);
			preorder_traverse(T.right);
			visited(T);
		}
	}
}
```

---

# 수식 트리

- 연산자 = 루트 노드 OR 가지 노드
- 피연산자 = 리프노드

# 이진 탐색 트리

- 탐색 작업을 효율적으로 하기 위한 자료구조
- 모든 노드는 서로 다른 유일한 키를 갖음
- 왼쪽 서브트리 key < 루트 노드 key < 오른쪽 서브트리 key
- `**중위순회**` 시, `**오름차순 정렬**` 값 얻을 수 있음

## 탐색연산

- 루트에서 시작
- 찾고자 하는 값이 루트보다
    - 크면 오른쪽 서브트리 탐색
    - 작으면 왼쪽 서브트리 탐색


## 삽입 연산

- 탐색 연산 수행
- 탐색 성공 시, 이미 트리에 있는 값
- 탐색 실패 시, 실패한 자리 = 삽입 위치
- 삽입 위치에 삽입

## 삭제 연산

- 탐색 연산 수행
- 삭제할 노드가
    - 단말 노드의 경우, 그냥 삭제
    - 자식 노드가 1개 일 때, 현재 노드 값을 자식 노드의 값으로 바꾸고 자식 노드를 삭제
    - 자식 노드가 2개 일 때
        1. 왼쪽 서브트리에서 가장 큰 값을 찾음
            - 해당 노드의 자식 노드가 없을 경우, 가장 큰 값의 노드를 루트 노드로 만듦
        2. 오른쪽 서브트리에서 가장 작은 값을 찾아서
            - 해당 노드의 자식 노드가 없을 경우, 가장 작은 값의 노드를 루트 노드로 만듦
            - 자식 노드가 있을 경우, 자식 노드를 본인자리로 옮긴 후, 작은 값을 루트 노드로 만듦


## 성능

- 트리의 높이 만큼 걸림
- O(h)
    - h = height
- 평균
    - 균형 있게 생성 → O(log n)
- 최악의 경우
    - 한 쪽으로 치우친 경사 이진트리 → O(n)
    - 순차탐색과 같음
    - 방법
        1. 이진 트리를 다진 트리로 변경
            1. 이 경우, 오버헤드가 심해질 수 있음
        2. 균형 이진 탐색 트리
            1. balance factor 값을 유지하는 트리
            2. 자식 노드가 있으면 1
            3. 자식 노드가 없으면 0
            4. 부모의 factor 값 = 왼쪽 자식노드의 balance factor - 오른쪽 자식 노드의 balance factor
            5. 루트 노드의 balance factor값이 0이 되게 만든다

---

# 힙 트리

<aside>
❓ 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해 만든 자료구조

</aside>

- 왼쪽 노드부터 완전 이진트리의 모습으로 채워 나감

## 최대 힙

- 부모 노드가 자식 노드보다 큰 값을 가짐

## 최소 힙

- 부모 노드가 자식 노드보다 작은 값을 가짐

## 삽입 연산(※ 최대 힙으로 설명)

1. 삽입할 자리 확장
2. 확장된 자리에 원소 저장
3. 부모 노드와 값 비교
    1. 부모 노드보다 값이 크다면 부모 노드와 자리 변경
    2. 부모 노드보다 값이 작을 때까지 반복

## 삭제 연산(※ 최대 힙으로 설명)

- 힙에서는 루트 노드만 삭제 가능
- 루트 노드의 원소를 삭제하여 반환함

1. 루트 노드 원소 삭제
2. 마지막 노드의 원소를 루트 노드로 이동
3. 루트 노드가 자식 노드 중 큰 값과 자리 변경
4. 자리 확정

- 힙트리는 우선순위 큐로 구현할 수 있음
# 1. 상속

## 특징
- 기존 클래스의 요소를 자식 클래스에서 재사용
  + 부모 클래스의 **생성자**와 **초기화 블록**은 상속 X
- 유지보수에 유리
- extends 키워드 사용
- 한 번에 하나의 클래스만 상속 가능


### Object 클래스
- 모든 클래스의 부모 클래스
- extends Object 생략

<br>

## 상속의 관계
### 단일 상속
- is-a 관계
- 자바는 단일 상속만 지원한다.
- 다중 상속을 구현하고 싶다면 **interface**나 **포함 관계 (has a)**로 구현

### has-a관계
```java
/* has a 관계 */
public class SpiderMan2 extends Person {
	Spider spider = new Spider();
	boolean isSpider;

	public void fireWeb(){
		if(isSpider) {
		spider.fireWeb();
	}
	else {
		System.out.println();
	}
}
```

- - -
## Overriding
- 조상 클래스에 정의된 메서드를 자식 클래스에서 수정하는 것
- 조건
  + 메서드 **이름**, arguments의 **개수, 타입, 순서**가 같아야 함
- @Override annotation
  + JDK 1.5부터 제공
  + 컴파일러에게 Override한 메서드임을 알림


### toString()
- 객체를 문자열로 표현
- override를 통해 원하는 형태로 출력 가능
- sysout 메서드 등을 활용

### equals()
- 두 객체가 같은지 비교
- 구현부에 특정 조건을 만족하는 경우 재정의하여 비교문에 활용
- 비교 기준이 명확 X -> 비교 기준을 재정의

### hashCode
- 객체의 해시 코드: 시스템에서 객체를 구별하기 위해 사용되는 정수 값
- HashSet, HashMap 등에서 객체의 동일성 확인을 위해 사용


- - -

## Super 키워드
- 부모 클래스의 필드, 메서드에 접근하기 위한 키워드
- 객체 생성 시, 자동 생성
- 자식 클래스 생성자 첫 줄에 호출

## this 키워드
- 객체 자신의 필드, 메서드에 접근하기 위한 키워드
- 객체 자신의 하나의 생성자에서 다른 생성자 호출 

- - - 

# 2. 캡슐화
- 접근 제한자를 통해 데이터 **은닉/보호** 가능


## 제한자
- 클래스, 변수, 메서드 선언부와 함께 사용
- 부가적 의미 부여

### 종류
#### 접근제한자
1. public - 누구든 접근 가능
2. protected - 상속받은 자만 가능
3. private - 나 자신 class 내부에서만 가능
4. package - 같은 패키지면 다 가능, default


#### 사용 제한자
1. static - 클래스 레벨(메모리 클래스 영역)의 요소 설정
2. final - 더이상 수정 불가
3. abstract - 추상 메서드, 추상 클래스 작성

## singleton 디자인 패턴
- 오로지 하나의 객체만 생성
- 외부에서 생성자에 접근 금지
- 외부에서 private 필드에 접근하기 위해서 getter 변수를 통해 객체 참조 & 변수에 static 추가

- - -
# 3. 다형성
> 하나의 객체가 많은 형을 가질 수 있는 성질
> 상속 관계에 있을 때, 부모 클래스의 타입으로 자식 클래스 객체 참조 가능
> 유지 보수 편리

## 예시
### 1. 다른 타입의 객체를 다루는 배열
- 다형성으로 다른 타입의 데이터를 하나의 배열로 관리 가능
- Object는 모든 클래스의 부모 클래스
	-> 어떤 타입의 객체라도 다 저장 가능
- 자바의 자료구조를 간단하게 처리 가능
	+ Collection API 등장
	+ Q. 기본형은 담을 수 있는가?
	+ A. **참조형이 아니라서 담을 수 없습니다. :)**

```java
Person[] ps = new Person[3];

ps[0] = new SpiderMan();
ps[1] = new Venom();
ps[2] = new Person();
```

#### Wrapper Class
- 기본형 변수를 참조형으로 사용하기 위해 생성된 클래스


### 2. argument의 다형성
- 메서드를 호출하려면 이름과 argument가 맞아야 하는데 부모 클래스를 argument로 처리


## 다형성과 참조형 객체의 형 변환
- 부모 클래스 변수에 자식 클래스 객체를 만들 수 있지만 호출할 수 있는 메서드는 부모 클래스의 메서드를 호출할 수 있음
- 부모 = 자식으로 타입 캐스팅 가능
- 단, 부모 클래스에 없는 메서드는 캐스팅 불가

### 참조형 객체의 형변환
1. 묵시적 형변환: 부모 클래스 = new 자식 클래스()
2. 명시적 형변환: 자식 클래스 = (자식 클래스) new 부모 클래스()
	+ 이 경우, 데이터를 우겨넣는 것이므로 명시적으로 표기해야 함

### 참조 변수의 레벨에 따른 객체의 필드, 메서드 연결
- 객체 필드 중복
	+ 참조 변수의 타입에 따라 연결이 달라짐
- 메서드 중복
	+ 무조건 자식 클래스의 메서드 호출
	+ Override는 참조 변수의 클래스 타입과 관계 없음

- - -
# 4. 추상화
## 추상화 클래스
### 정의
- 메서드의 선언부만 남기고 구현부 제거 -> 구현부를 세미콜론으로
- 구현부가 없어서 abstract 키워드를 선언부에 추가
- 클래스 내에 abstract 키워드가 하나라도 있으면 그 클래스는 **abstract class**가 되어야 한다

### 특징
#### 1. 상속 전용 클래스
- 클래스에 구현부가 없는 메서드가 있음
- 객체 생성이 불가능
- 자식 클래스에서 참조 가능

#### 2. 상속받은 abstract 메서드를 재정의하지 않은 경우
- 클래스 내부에 abstract 메서드가 있으므로 **자식 클래스 역시 추상화 클래스가 된다**
- 자식 중 하나는 재정의하여 사용해야 함 -> 물려받는 빚의 개념


### 사용 이유
- 구현의 강제를 통해 프로그래머에게 중요성을 인지 시킴
- UML 상에서는 이텔릭 표기

## 인터페이스
### 작성
- 클래스와 유사한 선언
- 모든 필드는 **public static final** -> 생략 가능
- 모든 메서드는 **public abstract** -> 생략 가능
- 선언부만 선언
- JDK 8부터 인터페이스에서 **메서드 구현 가능**
	+ 실무에서는 잘 사용 안 함
	+ **default method**
		* implements한 클래스에서 재정의 가능
		* 객체 상태일 때 호출 가능

	+ static method
		* 재정의 불가
		* 인터페이스 명, 메서드 형태로 호출 가능

### 구현 / 객체 참조
- 인터페이스끼리 extends로 상속 가능
- **implements**로 상속 받음
	+ 모든 abstract 메서드를 구현하거나 하나라도 구현 못한 것이 있을 경우, abstract class로 표기해야 함
	+ 다중 상속 가능
	+ 다형성은 클래스처럼 가능

### 필요성
- 구현의 강제로 표준화 가능
- 간접적 클래스 사용 -> **모듈 교체가 쉬움**
- 상속 관계가 아니지만 인터페이스를 통해 **다형성 확장**
- 독립적 프로그래밍 -> 사용하는 쪽과 구현하는 쪽의 **분리 가능**
